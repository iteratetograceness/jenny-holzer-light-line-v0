/**
 * Generated by v0: https://v0.dev/chat/-V1wnLTugT-
 */

'use client'

import React, { useEffect, useRef } from 'react'
import * as THREE from 'three'

interface StaticLedSignProps {
  lines: string[]
}

export function StaticLedSign({ lines }: StaticLedSignProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    if (!canvasRef.current) return

    const scene = new THREE.Scene()
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)
    const renderer = new THREE.WebGLRenderer({
      canvas: canvasRef.current,
      alpha: true,
    })

    const geometry = new THREE.PlaneGeometry(2, 2)
    const material = new THREE.ShaderMaterial({
      uniforms: {
        u_resolution: { value: new THREE.Vector2() },
        u_time: { value: 0 },
        u_texture: { value: null },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform sampler2D u_texture;
        varying vec2 vUv;

        float circle(in vec2 _st, in float _radius) {
          vec2 dist = _st - vec2(0.5);
          return 1.0 - smoothstep(_radius - (_radius * 0.01),
                                  _radius + (_radius * 0.01),
                                  dot(dist, dist) * 4.0);
        }

        void main() {
          vec2 st = vUv;
          st *= 250.0; // Increased number of dots for more detail
          
          vec2 ipos = floor(st);
          vec2 fpos = fract(st);

          float c = circle(fpos, 0.4); // Slightly larger dots
          
          vec4 color = texture2D(u_texture, vUv);
          float brightness = (color.r + color.g + color.b) / 3.0;
          
          vec3 ledColor = vec3(1.0, 0.6, 0.0); // More orange color
          vec3 finalColor = ledColor * brightness * c;
          
          // Add a slight glow effect
          finalColor += ledColor * brightness * 0.3;

          // Add some noise to simulate imperfect LEDs
          float noise = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);
          finalColor *= 0.9 + 0.1 * noise;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
    })

    const mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh)

    const containerRef = canvasRef.current.parentElement

    const resize = () => {
      if (!containerRef) return

      const rect = containerRef.getBoundingClientRect()
      const containerWidth = rect.width
      const containerHeight = rect.height

      renderer.setSize(containerWidth, containerHeight)
      material.uniforms.u_resolution.value.set(containerWidth, containerHeight)

      // Adjust the camera
      const aspect = containerWidth / containerHeight
      const frustumHeight = 1
      const frustumWidth = frustumHeight * aspect
      camera.left = -frustumWidth / 2
      camera.right = frustumWidth / 2
      camera.top = frustumHeight / 2
      camera.bottom = -frustumHeight / 2
      camera.updateProjectionMatrix()

      mesh.scale.set(aspect, 1, 1)
    }

    const createTextTexture = () => {
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      if (!ctx) return null

      canvas.width = 2048
      canvas.height = 1152 // 16:9 aspect ratio

      ctx.fillStyle = 'black'
      ctx.fillRect(0, 0, canvas.width, canvas.height)

      ctx.font = 'bold 140px Arial'
      ctx.fillStyle = 'white'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'

      const lineHeight = 180
      const startY = (canvas.height - (lines.length - 1) * lineHeight) / 2

      lines.forEach((line, index) => {
        ctx.fillText(
          line.toUpperCase(),
          canvas.width / 2,
          startY + index * lineHeight
        )
      })

      return new THREE.CanvasTexture(canvas)
    }

    const updateText = () => {
      const texture = createTextTexture()
      if (texture) {
        material.uniforms.u_texture.value = texture
      }
    }

    const animate = () => {
      requestAnimationFrame(animate)
      material.uniforms.u_time.value += 0.05
      renderer.render(scene, camera)
    }

    resize()
    updateText()
    animate()

    window.addEventListener('resize', resize)

    const resizeObserver = new ResizeObserver(resize)
    if (containerRef) {
      resizeObserver.observe(containerRef)
    }

    return () => {
      if (containerRef) {
        resizeObserver.unobserve(containerRef)
      }
      resizeObserver.disconnect()
      window.removeEventListener('resize', resize)
      renderer.dispose()
    }
  }, [lines])

  return (
    <div className='w-full h-0 pb-[56.25%] relative'>
      <canvas ref={canvasRef} className='absolute inset-0 w-full h-full' />
    </div>
  )
}
